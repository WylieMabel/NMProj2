---
editor_options: 
  markdown: 
    wrap: 72
---

# Network Modelling Project 2

**Matej Mrazek, Gabriele Spisani, Nicola Taddei, Mabel Wylie**

### Loading Data and Importing Packages

```{r}
install.packages('reticulate')
library(reticulate)
```

### Task 1:

#### 1)

This assumption is a good approximation for networks where agents make decisions based solely on the current state of the network, disregarding past states, and where the network's dynamics are either continuous or sufficiently slow relative to the discrete-time intervals. This allows a discrete-time system to be approximated by a continuous-time one.

For example, consider a network representing friendships in a high school class and the academic performance of each student. While the system may be naturally modeled as a discrete-time system—since students primarily interact in the classroom for specific hours each day—the gradual and slow changes in academic performance over a daily time scale make it reasonable to approximate this system as a Markovian continuous-time one.

In contrast, this assumption breaks down in networks such as business relationships among companies and the quality of their manufactured products. In the manufacturing industry, reputation often plays a significant role, meaning that relationships between companies are influenced by the past values of their attributes. As a result, the Markovian assumption is violated in this context.

#### 2)

This assumption models agents as conscious and fully aware of the entire network, as they are presumed to make decisions based on its structure and actor-level attributes.

The high school class and academic performance network is a fitting example where this assumption holds. In such a setting, students consciously choose their friendships according to network structure and agent attribues.

On the other hand, in a network representing infectious contacts between individuals and super-spreading phenomena (where an actor-level attribute models the conditional probability of infecting another individual given a contact), this assumption breaks down. In such cases, actors often have involuntary, indirect contacts with others—for example, through shared surfaces in public transportation—thereby violating the assumption.

#### 3)

This assumption is introduced to simplify the probability distribution governing changes in the network structure or attributes. It is a reasonable approximation in scenarios where changes occur gradually over time and are relatively slow.

For instance, consider a network where agents are companies, represented by a numerical value indicating their reputation, and a tie between two agents A and B signifies that company A is purchasing a service from company BB. In this case, events can be assumed to occur infrequently enough that they happen one at a time.

However, if we also consider ties representing both the acquisition and the sale of a service, network changes will involve two ties simultaneously, as each transaction entails one company buying and another selling. This would violate the assumption of single-event changes.

#### 4)

This assumption is necessary for agents to make decisions that optimize a network-level objective function.

For example, in the infectious contacts network discussed earlier, actors are unaware of the actor-level attributes and therefore cannot consciously make decisions to optimize a function of these attributes.

In contrast, in the high school class example, the network is small enough for everyone to be aware of each other's academic performance. This awareness enables students to form friendships based on this attribute, thereby allowing decisions that align with a network-level objective.


### Task 2: Network Evaluation Function

#### 1)

Using the RSiena manual, we write down the formulas for each effect as
follows:

-   Out-degree $s_{1i}(x) = \sum_j x_{ij}$

-   Reciprocity $s_{2i}(x) = \sum_j x_{ij} x_{ji}$

-   Transitive reciprocated triplets
    $s_{3i}(x) = \sum_{j, h} x_{ij} x_{ji} x_{ih} x_{hj}$

-   Indegree popularity
    $s_{4i}(x) = \sum_{j, k, j \neq k} x_{ji} x_{ki}$

-   Same covariate $s_{5i}(x, v) = \sum_j x_{ij} \mathbb{I}[v_i = v_j]$

Where $\mathbb{I}$ denotes the indicator function.

#### 2)

We considered it the easiest to write a quick python script that
implements each of the effects defined above. We can then run it on the
provided graph to obtain complete results (both $f_j$ and $p_j$ values
for every possible edge addition), which then makes it easy to answer
the provided questions. We share the python script below:

```{python}
print(hello)
```

```{python python.reticulate = FALSE}
import scipy


# All graph vertices
task_V = {
    'a': 'white',
    'b': 'white',
    'c': 'gray',
    'd': 'gray', 
}

# All directed graph edges
task_E  = [
    ('a', 'b'),
    ('a', 'd'),
    
    ('b', 'c'),
    
    ('c', 'a'),
    
    ('d', 'a'),
    ('d', 'b')
]


# equal to x_{ij} for the given edges
def x(E, i, j):
    return 1 if (i, j) in E else 0

# equal to v_i for the given vertex
def v(V, i):
    return V[i]

# indicator variable
def I(a):
    return 1 if a else 0


# out-degree
def s1i(V, E, i):
    return sum([x(E, i, j) for j in V.keys()])

# reciprocity
def s2i(V, E, i):
    return sum([x(E, i, j) * x(E, j, i) for j in V.keys()])

# transitive reciprocated triplets
def s3i(V, E, i):
    return sum([x(E, i, j) * x(E, j, i) * x(E, i, h) * x(E, h, j) for j in V.keys() for h in V.keys()])

# indegree popularity
def s4i(V, E, i):
    return sum([x(E, j, i) * x(E, k, i) for j in V.keys() for k in V.keys() if j != k])

# same covariate
def s5i(V, E, i):
    return sum([x(E, i, j) * I(V[i] == V[j]) for j in V.keys()])

# the total score of the given vertices and edges
def score(V, E):
    s1 = sum([s1i(V, E, i) for i in V.keys()])
    s2 = sum([s2i(V, E, i) for i in V.keys()])
    s3 = sum([s3i(V, E, i) for i in V.keys()])
    s4 = sum([s4i(V, E, i) for i in V.keys()])
    s5 = sum([s5i(V, E, i) for i in V.keys()])
    
    # compute total score using the provided beta values
    return -1.2 * s1 + 1.5 * s2 + 1 * s3 + 0.5 * s4 + 1.3 * s5
    
# print the probabilities for all operations for a selected actor i
def step(V, E, i):
    results = []
    # base score (no changes)
    base = score(V, E)
    # go over all possible edges to add / remove
    for j in V.keys():
        if i == j: # source = target -> do nothing action
            results.append(("Do nothing", 0))
        elif not x(E, i, j): # Edge not present in graph - we are adding it
            results.append((f"Adding {i} -> {j}", score(V, (E + [(i, j)])) - base))
        else: # Edge present in graph - we are removing it
            results.append((f"Removing {i} -> {j}", score(V, [e for e in E if e != (i, j)]) - base))
    ops, scores = zip(*results)

    # convert computed scores to probabilities for each action
    next_probs = scipy.special.softmax(scores)

    # print results
    print ("Next step probabilities:" + "".join([f"\n\t* {op}: f={score:.1f}, p={v:.3f}" for op, score, v in zip(ops, scores, next_probs)]))
    
for i in task_V:
    step(task_V, task_E, i)
```

The output is: Next step probabilities: \* Do nothing: f=0.0, p=0.022 \*
Removing a -\> b: f=-1.1, p=0.007 \* Adding a -\> c: f=3.8, p=0.968 \*
Removing a -\> d: f=-1.8, p=0.004 Next step probabilities: \* Adding b
-\> a: f=8.1, p=0.963 \* Do nothing: f=0.0, p=0.000 \* Removing b -\> c:
f=1.2, p=0.001 \* Adding b -\> d: f=4.8, p=0.036 Next step
probabilities: \* Removing c -\> a: f=0.2, p=0.010 \* Adding c -\> b:
f=4.8, p=0.959 \* Do nothing: f=0.0, p=0.008 \* Adding c -\> d: f=1.1,
p=0.024 Next step probabilities: \* Removing d -\> a: f=-2.8, p=0.006 \*
Removing d -\> b: f=0.2, p=0.117 \* Adding d -\> c: f=2.1, p=0.782 \* Do
nothing: f=0.0, p=0.096

We can now easily answer all the subtasks (assuming that each actor was
already selected for that particular ministep. To obtain the global
value - both sampling the actor and selecting this option - divide
percentage values by 4 to account for actor sampling.): \* Probability
that actor c adds a tie to b: $p=95.9\%$ \* Probability that actor b
adds a tie to a: $p=96.3\%$ \* Probability that actor a deletes the tie
to b: $p=0.7\%$ \* Probability that actor d does not change anything:
$p=9.6\%$

### Task 3:

#### 1)

### Task 2:

#### 1)
